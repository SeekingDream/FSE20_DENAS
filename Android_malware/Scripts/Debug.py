from Android_malware.Scripts.utils import *
from Android_malware.Scripts.ExplainModel import completeSingleNode


def get_debug_rules():
    model = loadModel(year=2019, )
    puppetModel = getPuppetModel("../model/" + str(2019) + "/MLP_model.h5")
    x, y = ReadData(year=2019, IsTrain=False)
    pred = model.predict(x, batch_size=1000) > 0.5
    pred = pred.reshape([-1])
    index = np.where((y == 0) * (pred == 1))
    x = x[index]
    with open('err_x.pkl', 'wb') as f:
        pickle.dump(x, f)
    RuleSet = []
    print('total err numer is ', len(x))
    for i in range(len(x)):
        data = x[i:i+1]
        st = datetime.datetime.now()
        NowNode = RuleStructure(data, [])
        NowNode.SetPredy(-100)
        rule = completeSingleNode(NowNode, puppetModel, model, np.zeros_like(data))
        RuleSet.append(rule)
        ed = datetime.datetime.now()
        print(ed - st)
    with open('debug_rule.pkl', 'wb') as f:
        pickle.dump(RuleSet, f)


def fixrule(rule, error_case, x, y, aug_num = 5):
    datanum = int(len(x))
    x = x[:datanum]
    y = y[:datanum]
    aug_x = x[:aug_num]
    for r in rule:
        aug_x[:, r[0]] = r[1]
    newx = np.concatenate((x, aug_x), 0)
    newy = np.concatenate((y, np.zeros([aug_num])), 0)
    np.random.seed(100)
    np.random.shuffle(newx)
    np.random.seed(100)
    np.random.shuffle(newy)
    model = loadModel(year=2019)
    model.fit(newx, newy, batch_size=128, epochs = 1, verbose = 0)
    new_pred = model.predict(error_case) > 0.5
    pred_y = (model.predict(x) > 0.5).reshape([-1])
    return np.sum(new_pred), np.sum(pred_y == y.reshape([-1]))/ len(y)





def getCoverage(RuleSet, x):
    coverMat = np.zeros([len(RuleSet), len(RuleSet)])
    for rindex in range(len(RuleSet)):
        rule = RuleSet[rindex]
        sel_index = np.ones(len(RuleSet))
        for r in rule:
            new = (x[:, r[0]] == r[1]).reshape([-1])
            sel_index = sel_index * new
        coverMat[rindex] = sel_index
    return coverMat


def debug():
    np.random.seed(100)
    with open('err_x.pkl', 'rb') as f:
        err_x = pickle.load(f)
    with open('debug_rule.pkl', 'rb') as f:
        err_Rule = pickle.load(f)
    err_Rule = [r.rule for r in err_Rule]
    new_Set = []
    for rule in err_Rule:
        newrule = []
        for r in rule:
            newrule.append([int(r/2), r%2])
        new_Set.append(newrule)
    coverMat = getCoverage(new_Set, err_x)
    coverNum = np.sum(coverMat, 1)

    sel = [0,1,2,3]

    sel_index = np.argsort(coverNum * -1)[sel]
    print('error number ', coverNum[sel_index])
    x, y = ReadData(year=2019, IsTrain=True)

    res = []
    acc_matrix = np.zeros([3, 4])
    for aj in range(3, 5):
        new_err_num = []
        for ai, i, in enumerate(sel_index):
            rule = new_Set[i]
            error_case = err_x[np.where(coverMat[i])]
            st = datetime.datetime.now()
            num, acc = fixrule(rule, error_case, x, y, aug_num = 10*aj)
            ed = datetime.datetime.now()
            print('cost time', ed - st, 'acc:', acc)
            new_err_num.append([num])
            acc_matrix[aj-3, ai] = acc
        print(new_err_num)


        res.append(new_err_num)
    print(res)
    np.savetxt('acc.csv', acc_matrix, delimiter=',')

def main():
    debug()


if __name__ == '__main__':
    main()