import os
os.environ["CUDA_VISIBLE_DEVICES"] = "1"
import datetime
import queue
from Pdf_malware.Scripts.utils import *

VECSIZE = [0]
FEANUM = 134
BIT = 2



def generateNewpt(NowNode, puppetModel, model):
    activationState = calAcStateFromRule(NowNode.rule, model)
    contributionVec = calContributionVec(puppetModel, activationState)
    oldcontributionVec = contributionVec.copy()

    for pt in NowNode.rule:
        contributionVec[int(pt / 2)] = 0

    NewNodeList = []

    global VECSIZE
    while len(NowNode.dataset) >= np.max(VECSIZE):
        NewNode = None
        predy = 0
        while NewNode == None:
            newpt = np.argmax(np.abs(contributionVec))
            if contributionVec[newpt] > 0:
                newpt = newpt * 2 + 1
            else:
                newpt = newpt * 2
            pos = int(newpt / 2)
            val = newpt % BIT
            NewNode = NowNode.SplitNode(newpt)
            if NewNode != None:
                predy = calPredy(oldcontributionVec, NewNode.rule)
            contributionVec[pos] = 0
        NewNode.SetPredy(predy)
        NewNodeList.append(NewNode)
        VECSIZE.append(len(NewNode.dataset))
    VECSIZE.append(len(NowNode.dataset))
    return NewNodeList, NowNode



def completeSingleNode(NowNode, puppetModel, model):
    activationState = calAcStateFromRule(NowNode.rule, model)
    contributionVec = calContributionVec(puppetModel, activationState)

    for pt in NowNode.rule:
        contributionVec[int(pt / BIT)] = 0

    while len(NowNode.rule) <= TerminationLength or NowNode.predy <= 0:
        newpt = np.argmax(np.abs(contributionVec))
        if contributionVec[newpt] > 0:
            newpt = newpt * 2 + 1
        else:
            newpt = newpt * 2

        pos = int(newpt / BIT)
        val = newpt % BIT

        if  NowNode.dataset[0, pos] == val:
            NowNode.rule.append(newpt)
            predy = calPredy(contributionVec, NowNode.rule)
            NowNode.SetPredy(predy)

        contributionVec[pos] = 0
    return NowNode




def main():
    model = load_model("../model/MLP_model.h5")
    puppetModel = getPuppetModel("../model/MLP_model.h5")
    x, y =  loaddata("../data/train_model_data.pkl")

    pos_x = x[np.where(y > 0)[0]]


    print("total input data number is ", len(x), "total malware is", np.sum(y))
    global  VECSIZE
    VECSIZE.append(len(pos_x))

    node = RuleStructure(pos_x, [])
    node.SetPredy(-100)
    myque = queue.PriorityQueue()
    myque.put(node)

    RuleSet = []
    SingLeRuleSet = []
    while len(RuleSet) < 30:
        st_time = datetime.datetime.now()
        NowNode = myque.get()
        del VECSIZE[np.argmax(VECSIZE)]
        if len(NowNode.dataset) <= 1:
            print("the rest data is the single point")
            break
        if NowNode.decideRule() == True:
            RuleSet.append(NowNode.rule)
            print("*************************************************************************")
            print("Find a rule cover data number is ", len(NowNode.dataset))
        else:
            NewNodeList, NowNode = generateNewpt(NowNode, puppetModel, model)
            for NewNode in NewNodeList:
                if len(NewNode.dataset) != 1:
                    myque.put(NewNode)
                else:
                    SingLeRuleSet.append(NewNode)
            if len(NowNode.dataset) != 1:
                myque.put(NowNode)
            else:
                SingLeRuleSet.append(NowNode)


        ed_time = datetime.datetime.now()
        print("Split a node cost Time : ", ed_time - st_time)


    # print("Single Rule Number is", len(SingLeRuleSet))
    # for SingleIndex in range(len(SingLeRuleSet)):
    #     SingleNode = SingLeRuleSet[SingleIndex]
    #     if len(SingleNode.dataset) == 1:
    #         Node = completeSingleNode(SingleNode, puppetModel, model)
    #         RuleSet.append(Node.rule)
    #         print("complete ,", SingleIndex, "Single Point")
    #     else:
    #         print("There is an error")
    return RuleSet









if __name__ == '__main__':
    st_time = datetime.datetime.now()
    RuleSet = main()
    ed_time = datetime.datetime.now()

    NewRuleSet = []
    for rule in RuleSet:
        newrule = []
        for r in rule:
            newrule.append([int(r / BIT), r % BIT])
        NewRuleSet.append(newrule)

    f = open("../RuleSet/RuleSet.pkl", "wb")
    pickle.dump(NewRuleSet, f)
    f.close()

