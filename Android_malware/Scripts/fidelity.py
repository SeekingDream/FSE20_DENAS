from Android_malware.Scripts.LEMNA import xai_rnn
from Android_malware.Scripts.TreeLearning import *
np.random.seed(1234)
import innvestigate




DEBUG = True

class FidelityMetric():
    def __init__(self, data, model, important, maxselNum, neg_x, step = 5):
        self.data = data.copy()
        self.important = important
        self.maxselNum = maxselNum
        self.neg_x  = neg_x
        self.step = step
        self.iter = int(maxselNum / step)
        self.model = model


    def AugmentTest(self):
        AugmentRes = []
        for i in range(self.iter):
            testdata = self.neg_x.copy()
            xpos = np.arange(0, len(self.data))
            for j in range(i * self.step):
                pos = np.int32(self.important[:, j])
                testdata[xpos, pos] = self.data[xpos, pos]
            AugmentRes.append(np.sum(self.model.predict(testdata) > 0.5) / len(self.data))
        return AugmentRes

    def DeductionTest(self):
        DeductionRes = []
        for i in range(self.iter):
            testdata = self.data.copy()
            xpos = np.arange(0, len(self.data))
            for j in range(i * self.step):
                pos = np.int32(self.important[:, j])
                testdata[xpos, pos] = 1 - self.data[xpos, pos]
            DeductionRes.append(np.sum(self.model.predict(testdata) > 0.5)/ len(self.data))
        return DeductionRes


class FidelityTest():
    def __init__(self, model, puppetmodel, x, y, neg_x, testNum = 100, selNum = 50):
        self.model = model
        self.puppetmodel = puppetmodel
        self.x = x[0 : testNum]
        self.y = y[0 : testNum]
        self.testNum = testNum
        self.selNum = selNum
        self.neg_x = neg_x[0 : testNum]
        self.baseline = [
            "gradient", #gradient
            "integrated_gradients",
            "deep_taylor",
        ]

    def Denasfidelity(self, ):
        importantInx = []
        for i in range(self.testNum):
            x = self.x[i: i + 1]
            rule = []
            importantpos = []
            while len(rule) <= self.selNum:
                activationState = calAcStateFromRule(rule, self.model)
                contributionVec = calContributionVec(self.puppetmodel, activationState)

                for pt in rule:
                    contributionVec[int(pt/2)] = 0

                add = 0
                while add <= 5:
                    newpt = np.argmax(np.abs(contributionVec))
                    if contributionVec[newpt] > 0:
                        newpt = newpt * 2 + 1
                    else:
                        newpt = newpt * 2
                    pos = int(newpt / BIT)
                    val = newpt % BIT
                    if x[0, pos] == val:
                        importantpos.append(pos)
                        rule.append(newpt)
                        add += 1
                    contributionVec[pos] = 0
            importantInx.append(np.array(importantpos))
        importantInx = np.array(importantInx)
        print("denas explain finished")

        if DEBUG:
            RuleSet = []
            for i in range(len(self.x)):
                rule = [[j, self.x[i, j]] for j in importantInx[i]]
                RuleSet.append(rule)
            f = open('../RuleSet/denas.pkl', 'wb')
            pickle.dump(RuleSet, f)
            f.close()


        metric = FidelityMetric(self.x, self.model, importantInx, self.selNum, self.neg_x)
        a = metric.AugmentTest()
        b = metric.DeductionTest()
        return a, b


    def Lemnafidelity(self,):
        importantInx = np.zeros_like(self.x, dtype= np.int32)
        for i in range(self.testNum):
            x_test = self.x[i: (i + 1)]
            xai_test = xai_rnn(self.model, x_test)
            importantInx[i] = xai_test.xai_feature(500)
        print("lemna finish extract explanation")

        RuleSet = []
        for i in range(len(self.x)):
            rule = [[j, self.x[i, j]] for j in importantInx[i]]
            RuleSet.append(rule)
        f = open('../RuleSet/lemna.pkl', 'wb')
        pickle.dump(RuleSet, f)
        f.close()

        metric = FidelityMetric(self.x, self.model, importantInx, self.selNum, self.neg_x)
        a = metric.AugmentTest()
        b = metric.DeductionTest()
        return a, b


    def Baselinefidelity(self, i_num, num = 10):
        importIndex = np.zeros([len(self.x), 200], dtype=np.float32)
        step = int(self.testNum / num)
        analyzer= innvestigate.create_analyzer(self.baseline[i_num], self.model)
        for i in range(num):
            st = int((i) * step)
            ed = min(int((i + 1) * step), len(self.x))
            analysis = analyzer.analyze(self.x[st : ed])
            importIndex[st : ed]= np.argsort(analysis * -1, axis= 1)[:, :200]

        importIndex = np.int32(importIndex)
        print(self.baseline[i_num], "finish explanation")

        if DEBUG:
            RuleSet = []
            for i in range(len(self.x)):
                rule = [[j, self.x[i, j]] for j in importIndex[i]]
                RuleSet.append(rule)
            f = open('../RuleSet/' + self.baseline[i_num] + '.pkl', 'wb')
            pickle.dump(RuleSet, f)
            f.close()
        metric = FidelityMetric(self.x, self.model, importIndex, self.selNum, self.neg_x)
        a = metric.AugmentTest()
        b = metric.DeductionTest()
        return a, b


    def Treefidelity(self):
        Ruleset = generateDTreeRuleSet(self.x, test_num=1000)




def getFidelityRes(fid ):
    AugplotArr = np.zeros([10, 6])
    DecplotArr = np.zeros([10, 6])
    baselineNum = 3
    x_axis = np.arange(0, 50, 5)

    for i in range(baselineNum):
        AugplotArr[:, i], DecplotArr[:, i] = fid.Baselinefidelity(i)
    AugplotArr[:, baselineNum], DecplotArr[:, baselineNum] = fid.Lemnafidelity()
    AugplotArr[:, baselineNum + 1], DecplotArr[:, baselineNum + 1] = fid.Denasfidelity()

    name = ["gradient", "ig", "deeptaylor", 'lemna', 'denas']
    L = []
    for i in range(baselineNum + 2):
        l, = plt.plot(x_axis, AugplotArr[:, i])
        L.append(l)
    plt.legend(handles=L, labels=name)
    plt.savefig('../Results/AugplotArr.png')
    plt.cla()

    L = []
    for i in range(baselineNum + 2):
        l, = plt.plot(x_axis, DecplotArr[:, i])
        L.append(l)
    plt.legend(handles=L, labels=name)
    plt.savefig('../Results/DecplotArr.png')



    print(AugplotArr)
    print(DecplotArr)
    np.savetxt("../Results/AugplotArr.csv", AugplotArr, delimiter=',')
    np.savetxt("../Results/DecplotArr.csv", DecplotArr, delimiter=',')




def main():
    model = loadModel(year=2019)
    puppetModel = getPuppetModel("../model/" + str(2019) + "/MLP_model.h5")
    x, y = ReadData(year=2019, IsTrain=False)

    if DEBUG:
        np.save('../Results/x', x)
        np.save('../Results/y', y)
        print('save raw data')

    print('Data_num:', len(x))
    pred_y = (model.predict(x, batch_size=1000) > 0.5)
    idx = np.nonzero(pred_y)[0]
    x_test = x[idx]
    y_test = y[idx]
    neg_x = x[np.where(pred_y == 0)[0]]


    fid = FidelityTest(model, puppetModel, x_test, y_test, neg_x, testNum=100)
    getFidelityRes(fid)
    print("finish accuracy experiments")



if __name__ == "__main__":
   main()