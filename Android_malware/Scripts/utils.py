import os
os.environ["TF_CPP_MIN_LOG_LEVEL"] = "2"
os.environ["CUDA_VISIBLE_DEVICES"] = "3"
import warnings
warnings.filterwarnings('ignore')
import pickle as pickle
import numpy as np
import datetime
from keras import Model
import keras
import queue
from keras.layers import Dense, Activation, Dropout, Layer
from keras.layers import  SimpleRNN, Embedding, Bidirectional,TimeDistributed
from keras.models import load_model
import keras.backend as K
import matplotlib.pyplot as plt


FEANUMDIC = {
    2018 : 282515,
    2017 : 282515,
    2016 : 282515,
    2015 : 282515,
    2014 : 282515,
    2013 : 282515,
    2012 : 282515,
    2011 : 282515,
    2019 : 282515,
}

BIT = 2
NowYear = 2019
TerminationLength = 10


class ActivePossible(Layer):
    def __init__(self, ac=None, **kwargs):
        # self.theta = theta
        # self.alpha1 = alpha1
        # self.alpha2 = alpha2
        self.ac = ac
       #self.activate = activate
        super(ActivePossible, self).__init__(**kwargs)


    def call(self, x):
        return K.cast(x, K.floatx()) * self.ac

        # fx_0 = K.relu(x)  # for x>0
        # fx_1 = self.alpha1 * x * K.cast(x > self.theta, K.floatx()) * K.cast(x <= 0.0, K.floatx())  # for theta<x<=0
        # fx_2 = self.alpha2 * x * K.cast(x <= self.theta, K.floatx())  # for x<=theta
        # return fx_0 + fx_1 + fx_2
        #return keras.layers.Multiply([x, self.activate])

    def compute_output_shape(self, input_shape):
        return input_shape

    def set_ac(self, ac):
        self.ac = ac


class RuleStructure():
    def __init__(self, dataset, rule):
        self.dataset = dataset
        self.rule = rule
        self.predy = 0
        self.size = len(self.dataset)

    def decideRule(self):
        if TerminationLength == len(self.rule) or (self.predy > 0 and len(self.rule) >= 5):
            return True
        else:
            return False


    def SetPredy(self, predy):
        self.predy = predy


    def SplitNode(self, newpt):
        pos = int(newpt / BIT)
        val = newpt % BIT
        selindex = np.where(self.dataset[:, pos] == val)[0]
        if len(selindex) == 0:
            return None
        else:
            newrule = self.rule.copy()
            newrule.append(newpt)
            newdataset = self.dataset[selindex].copy()
            NewNode = RuleStructure(newdataset, newrule)
            self.dataset = np.delete(self.dataset, selindex, axis=0)
            self.size = len(self.dataset)
            return NewNode

    @property
    def __eq__(self, other):
        return len(self.dataset) == len(other.dataset)
    def __lt__(self, other):
        return -len(self.dataset) < -len(other.dataset)


def ReadData(year = NowYear, IsTrain = True):
    if year != 2019:
        if IsTrain == True:
            f = open("data\\" + str(year) + "\\train.pkl", "rb")
        else:
            f = open("data\\" + str(year) + "\\test.pkl", "rb")
        data = pickle.load(f)
        f.close()
        x = data[0]
        y = data[1]
        return x, y
    else:
        if IsTrain == True:
            x = np.load("../data/2019/x_train.npy")
            y = np.load("../data/2019/y_train.npy")
        else:
            x = np.load("../data/2019/x_test.npy")
            y = np.load("../data/2019/y_test.npy")
        y = y.reshape([len(y)])
        return x, y

def loadModel(year = NowYear, fileName = None):
    if fileName == None:
        model = load_model("../model/" + str(year) + "/MLP_model.h5")
    else:
        model = load_model("../model/" + fileName)
    return model


def set_acpos(model, ac, index):
    for i in range(len(ac)):
        model.layers[int(index[i])].set_ac(ac[i])
    return model


def getPuppetModel(modelname):
    m = load_model(modelname)
    model = keras.Sequential()

    model.add(Dense(50, input_shape=[FEANUMDIC[NowYear]], activation= None))
    model.layers[-1].set_weights(m.layers[0].get_weights())
    model.add(ActivePossible(ac = np.ones([50]))) #############1111111###############

    model.add(Dense(50, activation= None))
    model.layers[-1].set_weights(m.layers[3].get_weights())
    model.add(ActivePossible(ac=np.ones([50])))  #############1111111###############

    model.add(Dense(1, activation= None))
    model.layers[-1].set_weights(m.layers[6].get_weights())

    return model


def getAvailableFeature(year = NowYear):
    f = open("rawdata\\" + str(year) + "\\feature_tag.txt", "r", encoding="utf8")
    lines = f.readlines()
    namelist = [0 for _ in range(FEANUMDIC[NowYear])]
    for line in lines:
        for i in range(1, 10):
            if line[-i] == ':':
                break
        name = line[0: -i]
        num = int(line[-i + 1: len(line)])
        namelist[num] = name
    f.close()
    return set([2*i for i in range(len(namelist)) if namelist[i] != 0]).union([2*i+1 for i in range(len(namelist)) if namelist[i] != 0])



def getNameList(year = NowYear):
    f = open("rawdata\\" + str(year) + "\\feature_tag.txt", "r",  encoding="utf8")
    lines = f.readlines()
    namelist =  [0 for _ in range(FEANUMDIC[NowYear])]
    for line in lines:
        for i in range(1, 10):
            if line[-i] == ':':
                break
        name = line[0 : -i]
        num = int(line[-i+1 : len(line)])
        namelist[num] = name
    f.close()
    for i in range(FEANUMDIC[NowYear]):
        if namelist[i] == 0:
            namelist[i] = "*******************************"
    return namelist


def getActiveNode(lay_0, lay_3,seed):
    dataNum = len(seed)
    activationNode = np.zeros([dataNum, 100])
    activationNode[:, 0 : 50] = \
        lay_0.predict(seed, batch_size= 20000).reshape(dataNum, 50)
    activationNode[:, 50 : 100] = \
        lay_3.predict(seed, batch_size= 20000).reshape(dataNum, 50)
    return activationNode


def getActivateState(model, x):
    lay_0 = Model(inputs=model.input,
                  outputs=model.layers[0].output)
    lay_3 = Model(inputs=model.input,
                  outputs=model.layers[3].output)

    activationNode = getActiveNode(lay_0, lay_3, x)
    return activationNode


def calAcStateFromRule(nowrule, model, testNum = 300):
    data = np.random.randint(0, BIT, [testNum, FEANUMDIC[NowYear]])
    for r in nowrule:
        pos = int(r / BIT)
        val = r % BIT
        data[:, pos] = val
    acstate = getActivateState(model, data) > 0
    acstate = np.mean(acstate, axis=0)
    return acstate


def calContributionVec(puppetModel, activationPossible):
    activationPossible = activationPossible.reshape([2, 50])
    puppetModel = set_acpos(puppetModel, activationPossible, [1, 3, ])
    contribution = getGradient(puppetModel)
    return contribution[0]


def getGradient(puppetModel):
    output = puppetModel.output
    input = puppetModel.input
    gradients = K.gradients(output, input)[0]

    out = K.function([input], [gradients])
    x = np.zeros([1, FEANUMDIC[NowYear]])
    y = out([x])[0]
    return  y


def calPredy(contributionVec, rule, puppetModel, mean_vec):
    base = np.zeros([1, FEANUMDIC[NowYear]])
    base = puppetModel.predict(base)
    y = np.sum(base)
    rulepos = []
    for r in rule:
        rulepos.append(int(r / BIT))

    for i in range(FEANUMDIC[NowYear]):
        if i not in rulepos and mean_vec[i] != 0:
            if contributionVec[i] < 0:
                y += (contributionVec[i] ) * mean_vec[i]
            else:
                y += (contributionVec[i] / BIT) * mean_vec[i]
    for r in rule:
        pos = int(r / BIT)
        val = r % BIT
        if val == 1:
            y += contributionVec[pos]
        # else:
        #     y -= contributionVec[pos]
    return y


def PlotName(RuleSet):
    name = getNameList(year = 2011)
    for rule in RuleSet:
        for r in rule:
            print(name[r[0]], r[1])
        print("#######################")
    return 0


def readRuleSetfromTXT(filename):
    RuleSet = []
    f = open(filename, 'r')
    StrSet = f.readlines()
    f.close()
    for strrule in StrSet:
        strrule = strrule[0:-2]
        rule = strrule.split(" ")
        for i in range(len(rule)):
            rule[i] = int(rule[i])
        RuleSet.append(rule)
    NewRuleSet = []
    for rule in RuleSet:
        newrule = []
        for r in rule:
            newrule.append([int(r / BIT), r % BIT])
        NewRuleSet.append(newrule)
    return NewRuleSet


def ReadRuleSet(fileName):
    f = open(fileName, "rb")
    RuleSet = pickle.load(f)
    f.close()
    return RuleSet




def transferRuleSet(RuleSet):
    NewRuleSet = []
    for rule in RuleSet:
        newrule = []
        for r in rule:
            newrule.append([int(r / BIT), r % BIT])
        NewRuleSet.append(newrule)
    return NewRuleSet